import GA


class VulnerabilityScanner:
    def __init__(self, binaryAnalyzer):
        self.vulnerabilityPath = []
        self.hasReentrancy = 0
        self.hasTimestamp = 0
        self.hasOverflow = 0
        self.hasTaintOwner = 0
        self.hasDos = 0
        self.binaryAnalyzer = binaryAnalyzer

    def detectReentrancy(self):
        count = 0
        print('可重入漏洞路径：')
        # 源代码表现形式为now或block.timestamp出现在分支语句中，在字节码形式上表现形式为TIMESTAMP出现在JUMPI的跳转条件上
        for block in self.binaryAnalyzer.pos2BlockMap.values():
            if 'GAS CALL' in block.instrString and block.moneyCall is True:
                # todo:前向搜索
                self.forwardSearch(block)
                # for i in self.vulnerabilityPath:
                #     print(i)
                print(self.vulnerabilityPath[0])
                count += GA.genetic_algorithm(self.vulnerabilityPath[0], self.binaryAnalyzer.pos2BlockMap)
                self.vulnerabilityPath.clear()
                # return True
        return count

    def detectTimestamp(self):
        count = 0
        print('时间戳依赖漏洞路径：')
        # 源代码表现形式为now或block.timestamp出现在分支语句中，在字节码形式上表现形式为TIMESTAMP出现在JUMPI的跳转条件上
        for block in self.binaryAnalyzer.pos2BlockMap.values():
            if 'TIMESTAMP' in block.conditionalJumpExpression:
                # todo:前向搜索
                self.forwardSearch(block)
                # for i in self.vulnerabilityPath:
                #     print(i)
                print(self.vulnerabilityPath[0])
                count += GA.genetic_algorithm(self.vulnerabilityPath[0], self.binaryAnalyzer.pos2BlockMap)
                self.vulnerabilityPath.clear()
                # return True
        return count

    def detectOverflow(self):
        count = 0
        print('整数溢出漏洞路径：')
        for block in self.binaryAnalyzer.pos2BlockMap.values():
            if any(x in block.instrString for x in ['ADD', 'SUB']):
                if 'RETURN' in block.instrString or 'PUSH29' in block.instrString or 'CALL' in block.instrString or 'JUMPI' in block.instrString:
                    pass
                else:
                    self.forwardSearch(block)
                    print(self.vulnerabilityPath[0])
                    count += GA.genetic_algorithm(self.vulnerabilityPath[0], self.binaryAnalyzer.pos2BlockMap)
                    self.vulnerabilityPath.clear()
        return count

    def detectTaintOwner(self):
        pass

    def detectDos(self):
        count = 0
        print('DoS攻击漏洞路径：')
        for block in self.binaryAnalyzer.pos2BlockMap.values():
            if block.isCircle:
                count = 1
                # self.forwardSearch(block)
                # print(self.vulnerabilityPath[0])
                # count += GA.genetic_algorithm(self.vulnerabilityPath[0], self.binaryAnalyzer.pos2BlockMap)
                # self.vulnerabilityPath.clear()
        return count

    def printResult(self):
        res = ""
        res += "Timestamp Dependency Vulnerability: " + str(self.hasTimestamp) + "\n"
        res += "Overflow Vulnerability: " + str(self.hasOverflow) + "\n"
        res += "reentrancy Vulnerability: " + str(self.hasReentrancy) + "\n"
        res += "DoS Attack Vulnerability: " + str(self.hasDos) + "\n"
        print(res)
        return res

    def scanVulnerability(self):
        self.hasTimestamp = self.detectTimestamp()
        self.hasOverflow = self.detectOverflow()
        self.hasReentrancy = self.detectReentrancy()
        self.hasDos = self.detectDos()
        self.printResult()

    def forwardSearch(self, block):
        if len(self.vulnerabilityPath) == 0:
            self.vulnerabilityPath.append([block.startBlockPos])
        else:
            self.vulnerabilityPath[-1].append(block.startBlockPos)
        prefixBlocksPos = list(block.prefixBlock)
        if len(prefixBlocksPos) == 0 or (block.function.isdigit() and not block.isCalledContract):  # 无边连接，头结点，搜索终止
            pass
        elif len(prefixBlocksPos) == 1:  # 只有一条边连接
            self.forwardSearch(self.binaryAnalyzer.pos2BlockMap[prefixBlocksPos[0]])
        else:
            # todo:还有循环
            val = 0
            candidateBlocks = []
            for prefixPos in prefixBlocksPos:  # 先排序，删除一些不合适的边，生成新[]，再选择最合适的block
                prefixBlock = self.binaryAnalyzer.pos2BlockMap[prefixPos]
                # 准则1：跨合约，优先级+2
                if prefixBlock.isCallFunction or (prefixBlock.calledFunctionJumpPos != -1 and block.isCallFunction):
                    val += 2
                # 准则2：数据依赖相关，+2
                if 'SSTORE' in prefixBlock.instrString:
                    val += 2
                # 准则3：return，+1
                if 'RETURN' in prefixBlock.instrString:
                    val += 1
                # 准则4：长度，正相关
                if prefixBlock.instrList:
                    val += (len(prefixBlock.instrList) / 100.0)
                candidateBlocks.append((prefixPos, val))
                val = 0
            candidateBlocks.sort(key=lambda t: t[1], reverse=True)
            # print(candidateBlocks)
            maxVal = candidateBlocks[0][1]
            currentPath = self.vulnerabilityPath[-1].copy()
            for pos, val in candidateBlocks:
                if val < 1 and maxVal >= 2:
                    continue
                if self.vulnerabilityPath[-1] != currentPath:
                    self.vulnerabilityPath.append(currentPath)
                self.forwardSearch(self.binaryAnalyzer.pos2BlockMap[pos])
