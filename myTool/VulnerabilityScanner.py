class VulnerabilityScanner:
    def __init__(self, binaryAnalyzer):
        self.vulnerabilityPath = []
        self.hasReentrancy = False
        self.hasTimestamp = False
        self.hasOverflow = False
        self.hasTaintOwner = False
        self.hasDos = False
        self.binaryAnalyzer = binaryAnalyzer

    def detectReentrancy(self):
        pass

    def detectTimestamp(self):
        # 源代码表现形式为now或block.timestamp出现在分支语句中，在字节码形式上表现形式为TIMESTAMP出现在JUMPI的跳转条件上
        for block in self.binaryAnalyzer.pos2BlockMap.values():
            if 'TIMESTAMP' in block.conditionalJumpExpression:
                # todo:前向搜索
                self.forwardSearch(block)
                for i in self.vulnerabilityPath:
                    print(i)
                self.vulnerabilityPath.clear()
                # return True
        return False

    def detectOverflow(self):
        # todo:整数溢出检测
        return False

    def detectTaintOwner(self):
        pass

    def detectDos(self):
        pass

    def printResult(self):
        res = ""
        res += "Timestamp Dependency Vulnerability: " + str(self.hasTimestamp) + "\n"
        res += "Overflow Vulnerability: " + str(self.hasOverflow) + "\n"
        print(res)
        return res

    def scanVulnerability(self):
        self.hasTimestamp = self.detectTimestamp()
        self.hasOverflow = self.detectOverflow()
        # self.printResult()

    def forwardSearch(self, block):
        if len(self.vulnerabilityPath) == 0:
            self.vulnerabilityPath.append([block.startBlockPos])
        else:
            self.vulnerabilityPath[-1].append(block.startBlockPos)
        prefixBlocksPos = list(block.prefixBlock)
        if len(prefixBlocksPos) == 0:  # 无边连接，头结点，搜索终止
            pass
        elif len(prefixBlocksPos) == 1:  # 只有一条边连接
            self.forwardSearch(self.binaryAnalyzer.pos2BlockMap[prefixBlocksPos[0]])
        else:
            # todo:还有循环
            val = 0
            candidateBlocks = []
            for prefixPos in prefixBlocksPos:  # 先排序，删除一些不合适的边，生成新[]，再选择最合适的block
                prefixBlock = self.binaryAnalyzer.pos2BlockMap[prefixPos]
                # 准则1：跨合约，优先级+2
                if prefixBlock.isCallFunction or (prefixBlock.calledFunctionJumpPos != -1 and block.isCallFunction):
                    val += 2
                # 准则2：数据依赖相关，+2
                # if block.evmStack:
                # 准则3：return，+1
                if 'RETURN' in prefixBlock.instrString:
                    val += 1
                # 准则4：长度，正相关
                if prefixBlock.instrList:
                    val += (len(prefixBlock.instrList) / 100.0)
                candidateBlocks.append((prefixPos, val))
                val = 0
            candidateBlocks.sort(key=lambda t: t[1], reverse=True)
            # print(candidateBlocks)
            maxVal = candidateBlocks[0][1]
            currentPath = self.vulnerabilityPath[-1].copy()
            for pos, val in candidateBlocks:
                if val < 1 and maxVal >= 2:
                    continue
                if self.vulnerabilityPath[-1] != currentPath:
                    self.vulnerabilityPath.append(currentPath)
                self.forwardSearch(self.binaryAnalyzer.pos2BlockMap[pos])
