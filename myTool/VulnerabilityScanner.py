class VulnerabilityScanner:
    def __init__(self, binaryAnalyzer):
        self.vulnerabilityPath = []
        self.hasReentrancy = False
        self.hasTimestamp = False
        self.hasOverflow = False
        self.hasTaintOwner = False
        self.hasDos = False
        self.binaryAnalyzer = binaryAnalyzer

    def detectReentrancy(self):
        pass

    def detectTimestamp(self):
        # 源代码表现形式为now或block.timestamp出现在分支语句中，在字节码形式上表现形式为TIMESTAMP出现在JUMPI的跳转条件上
        for block in self.binaryAnalyzer.pos2BlockMap.values():
            if 'TIMESTAMP' in block.conditionalJumpExpression:
                # todo:前向搜索
                self.forwardSearch(block)
                return True
        return False

    def detectOverflow(self):
        # todo:整数溢出检测
        return False

    def detectTaintOwner(self):
        pass

    def detectDos(self):
        pass

    def printResult(self):
        res = ""
        res += "Timestamp Dependency Vulnerability: " + str(self.hasTimestamp) + "\n"
        res += "Overflow Vulnerability: " + str(self.hasOverflow) + "\n"
        print(res)
        return res

    def scanVulnerability(self):
        self.hasTimestamp = self.detectTimestamp()
        self.hasOverflow = self.detectOverflow()
        # self.printResult()

    def forwardSearch(self, block):
        pass
        # self.vulnerabilityPath[-1].append(block.startBlockPos)
        # prefixBlocks = list(block.prefixBlock)
        # if len(prefixBlocks) == 0:  # 无边连接，头结点，搜索终止
        #     pass
        # elif len(prefixBlocks) == 1:  # 只有一条边连接
        #     self.forwardSearch(self.binaryAnalyzer.pos2BlockMap[prefixBlocks[0]])
        # else:
        #     # todo:还有循环
        #     for prefix in prefixBlocks:
        #         pass
        #         # 先排序，删除一些不合适的边，生成新[]，再选择最合适的block
